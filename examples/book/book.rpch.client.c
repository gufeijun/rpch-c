// This is code generated by hgen. DO NOT EDIT!!!
// hgen version: v0.1.7
// source: book.gfj

#include "book.rpch.client.h"

#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#include "argument.h"
#include "cJSON.h"
#include "error.h"
#include "client.h"

static inline __attribute__((always_inline)) void Account_init(struct Account*);
static inline __attribute__((always_inline)) void Account_destroy(struct Account*);
static inline __attribute__((always_inline)) void Book_init(struct Book*);
static inline __attribute__((always_inline)) void Book_destroy(struct Book*);
static inline __attribute__((always_inline)) void Price_init(struct Price*);
static inline __attribute__((always_inline)) void Price_destroy(struct Price*);

void Account_init(struct Account* data) {
	data->userName = NULL;
}
void Account_destroy(struct Account* data) {
	free(data->userName);
}
void Account_delete(struct Account* arg) {
	Account_destroy(arg);
	free(arg);
}
void Book_init(struct Book* data) {
	data->price = malloc(sizeof(struct Price));
	Price_init(data->price);
	data->name = NULL;
}
void Book_destroy(struct Book* data) {
	Price_destroy(data->price);
	free(data->price);
	free(data->name);
}
void Book_delete(struct Book* arg) {
	Book_destroy(arg);
	free(arg);
}
void Price_init(struct Price* data) {
	data->unit = NULL;
}
void Price_destroy(struct Price* data) {
	free(data->unit);
}
void Price_delete(struct Price* arg) {
	Price_destroy(arg);
	free(arg);
}

#define invalid_argcnt(err, want, got) \
    errorf(err, "expected count of arugments is %d, but got %d", want, got)
#define invalid_type(err, want, got) \
    errorf(err, "expected argument type: %s, but got %s", want, got)
#define invalid_type_size(err, t, want, got) \
    errorf(err, "expected size for type %s is %d, but got %d", t, want, got)
#define CHECK_ARG_CNT(want, got)                   \
    {                                              \
        if (got != want) {                         \
            invalid_argcnt(err, got, req->argcnt); \
			goto end;                                \
        }                                          \
    }
#define CHECK_ARG_TYPE(want, got)         \
    {                                     \
        if (strcmp(want, got) != 0) {     \
            invalid_type(err, want, got); \
			goto end;                       \
        }                                 \
    }
#define CHECK_ARG_SIZE(t, want, got)              \
    {                                             \
        if (want != got) {                        \
            invalid_type_size(err, t, want, got); \
			goto end;                               \
        }                                         \
    }
#define MARSHAL_FAILED(obj) error_put(err, "marshal struct " obj " failed");
#define UNMARSHAL_FAILED(obj) error_put(err, "unmarshal struct " obj " failed")

static cJSON* Account_marshal(struct Account* arg, error_t* err);
static cJSON* Book_marshal(struct Book* arg, error_t* err);
static cJSON* Price_marshal(struct Price* arg, error_t* err);

cJSON* Account_marshal(struct Account* data, error_t* err) {
	cJSON* root = NULL;
	
	if (data == NULL) goto bad;
    root = cJSON_CreateObject();
    if (!root) goto bad;
	if (data->userName == NULL) data->userName = "";
    if (cJSON_AddStringToObject(root, "userName", data->userName) == NULL) goto bad;
    if (cJSON_AddNumberToObject(root, "balance", (double)data->balance) == NULL) goto bad;
	return root;
bad:
	if (!err->null) MARSHAL_FAILED("Account")
    if (root) cJSON_Delete(root);
	return NULL;
}

cJSON* Book_marshal(struct Book* data, error_t* err) {
	cJSON* root = NULL;
	cJSON* item = NULL;
	
	if (data == NULL) goto bad;
    root = cJSON_CreateObject();
    if (!root) goto bad;
    if (data->price == NULL) {
        if (cJSON_AddNullToObject(root, "price") == NULL) goto bad;
    } else {
		item = Price_marshal(data->price, err);
		if (!err->null) goto bad;
    	if (!cJSON_AddItemToObject(root, "price", item)) goto bad;
    }
	if (data->name == NULL) data->name = "";
    if (cJSON_AddStringToObject(root, "name", data->name) == NULL) goto bad;
	return root;
bad:
	if (!err->null) MARSHAL_FAILED("Book")
    if (root) cJSON_Delete(root);
	return NULL;
}

cJSON* Price_marshal(struct Price* data, error_t* err) {
	cJSON* root = NULL;
	
	if (data == NULL) goto bad;
    root = cJSON_CreateObject();
    if (!root) goto bad;
	if (data->unit == NULL) data->unit = "";
    if (cJSON_AddStringToObject(root, "unit", data->unit) == NULL) goto bad;
    if (cJSON_AddNumberToObject(root, "num", (double)data->num) == NULL) goto bad;
	return root;
bad:
	if (!err->null) MARSHAL_FAILED("Price")
    if (root) cJSON_Delete(root);
	return NULL;
}
static void Account_unmarshal(struct Account* dst, char* data, error_t* err);
static void Book_unmarshal(struct Book* dst, char* data, error_t* err);
static void Price_unmarshal(struct Price* dst, char* data, error_t* err);

void Account_unmarshal(struct Account* dst, char* data, error_t* err) {
    cJSON* root = NULL;
    cJSON* item = NULL;

    root = cJSON_Parse(data);
    if (!root) goto bad;
    item = cJSON_GetObjectItemCaseSensitive(root, "userName");
	if (!item || !cJSON_IsString(item)) goto bad;
	dst->userName = strdup(cJSON_GetStringValue(item));
    item = cJSON_GetObjectItemCaseSensitive(root, "balance");
	if (!item || !cJSON_IsNumber(item)) goto bad;
	dst->balance = (float)item->valuedouble;
    cJSON_Delete(root);
    return;
bad:
    if (!err->null) UNMARSHAL_FAILED("Account");
    if (root) cJSON_Delete(root);
}

void Book_unmarshal(struct Book* dst, char* data, error_t* err) {
    cJSON* root = NULL;
    cJSON* item = NULL;

    root = cJSON_Parse(data);
    if (!root) goto bad;
    item = cJSON_GetObjectItemCaseSensitive(root, "price");
    if (cJSON_IsNull(item))
        dst->price = NULL;
    else {
		if (!item || !cJSON_IsObject(item)) goto bad;
    	data = cJSON_Print(item);
		Price_unmarshal(dst->price, data, err);
		if (!err->null) goto bad;
    }
    item = cJSON_GetObjectItemCaseSensitive(root, "name");
	if (!item || !cJSON_IsString(item)) goto bad;
	dst->name = strdup(cJSON_GetStringValue(item));
    cJSON_Delete(root);
    return;
bad:
    if (!err->null) UNMARSHAL_FAILED("Book");
    if (root) cJSON_Delete(root);
}

void Price_unmarshal(struct Price* dst, char* data, error_t* err) {
    cJSON* root = NULL;
    cJSON* item = NULL;

    root = cJSON_Parse(data);
    if (!root) goto bad;
    item = cJSON_GetObjectItemCaseSensitive(root, "unit");
	if (!item || !cJSON_IsString(item)) goto bad;
	dst->unit = strdup(cJSON_GetStringValue(item));
    item = cJSON_GetObjectItemCaseSensitive(root, "num");
	if (!item || !cJSON_IsNumber(item)) goto bad;
	dst->num = (float)item->valuedouble;
    cJSON_Delete(root);
    return;
bad:
    if (!err->null) UNMARSHAL_FAILED("Price");
    if (root) cJSON_Delete(root);
}

struct Book* bookMarket_getBook(char* arg1, client_t* client) {
	int free_data = 1;
    struct client_request req;
    struct argument resp;
	error_t* err = &client->err;struct Book* v = NULL;

	client_request_init(&req, "bookMarket", "getBook", 1);
	arg1 = arg1 == NULL ? "" : arg1;
	argument_init_with_option(req.args + 0, 0, "string", arg1, strlen(arg1));
	client_call(client, &req, &resp);
    if (!client->err.null) goto end;
	CHECK_ARG_TYPE("Book", resp.type_name)
	v = malloc(sizeof(struct Book));
	Book_init(v);
	Book_unmarshal(v, resp.data, &client->err);
	
end:
    if (resp.data && free_data) free(resp.data);
    if (resp.type_name) free(resp.type_name);
    return v;
}

struct Account* bookMarket_consume(struct Book* arg1, struct Account* arg2, client_t* client) {
	int free_data = 1;
    struct client_request req;
    struct argument resp;
	error_t* err = &client->err;
	char* data = NULL;
    cJSON* node1 = NULL;
    cJSON* node2 = NULL;struct Account* v = NULL;

	client_request_init(&req, "bookMarket", "consume", 2);
	node1 = Book_marshal(arg1, &client->err);
	if (client_failed(client)) return v;
	data = cJSON_Print(node1);
	argument_init_with_option(req.args + 0, 2, "Book", data, strlen(data));
	
	node2 = Account_marshal(arg2, &client->err);
	if (client_failed(client)) return v;
	data = cJSON_Print(node2);
	argument_init_with_option(req.args + 1, 2, "Account", data, strlen(data));
	
	client_call(client, &req, &resp);
    if (!client->err.null) goto end;
	CHECK_ARG_TYPE("Account", resp.type_name)
	v = malloc(sizeof(struct Account));
	Account_init(v);
	Account_unmarshal(v, resp.data, &client->err);
	
end:
    if (resp.data && free_data) free(resp.data);
    if (resp.type_name) free(resp.type_name);
    if (node1) cJSON_Delete(node1);
    if (node2) cJSON_Delete(node2);
    return v;
}

void bookMarket_updateBookPrice(char* arg1, struct Price* arg2, client_t* client) {
	int free_data = 1;
    struct client_request req;
    struct argument resp;
	char* data = NULL;
    cJSON* node1 = NULL;

	client_request_init(&req, "bookMarket", "updateBookPrice", 2);
	arg1 = arg1 == NULL ? "" : arg1;
	argument_init_with_option(req.args + 0, 0, "string", arg1, strlen(arg1));
	node1 = Price_marshal(arg2, &client->err);
	if (client_failed(client)) return;
	data = cJSON_Print(node1);
	argument_init_with_option(req.args + 1, 2, "Price", data, strlen(data));
	
	client_call(client, &req, &resp);
    if (!client->err.null) goto end;
end:
    if (resp.data && free_data) free(resp.data);
    if (resp.type_name) free(resp.type_name);
    if (node1) cJSON_Delete(node1);
    return;
}

void bookMarket_shelve(struct Book* arg1, client_t* client) {
	int free_data = 1;
    struct client_request req;
    struct argument resp;
	char* data = NULL;
    cJSON* node1 = NULL;

	client_request_init(&req, "bookMarket", "shelve", 1);
	node1 = Book_marshal(arg1, &client->err);
	if (client_failed(client)) return;
	data = cJSON_Print(node1);
	argument_init_with_option(req.args + 0, 2, "Book", data, strlen(data));
	
	client_call(client, &req, &resp);
    if (!client->err.null) goto end;
end:
    if (resp.data && free_data) free(resp.data);
    if (resp.type_name) free(resp.type_name);
    if (node1) cJSON_Delete(node1);
    return;
}
