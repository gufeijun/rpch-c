// This is code generated by hgen. DO NOT EDIT!!!
// hgen version: v0.1.5
// source: string.gfj

#include "string.rpch.server.h"

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "argument.h"
#include "cJSON.h"
#include "error.h"
#include "request.h"
#include "server.h"



#define invalid_argcnt(err, want, got) \
    errorf(err, "expected count of arugments is %d, but got %d", want, got)
#define invalid_type(err, want, got) \
    errorf(err, "expected argument type: %s, but got %s", want, got)
#define invalid_type_size(err, t, want, got) \
    errorf(err, "expected size for type %s is %d, but got %d", t, want, got)
#define CHECK_ARG_CNT(want, got)                   \
    {                                              \
        if (got != want) {                         \
            invalid_argcnt(err, got, req->argcnt); \
			return;                                \
        }                                          \
    }
#define CHECK_ARG_TYPE(want, got)         \
    {                                     \
        if (strcmp(want, got) != 0) {     \
            invalid_type(err, want, got); \
			return;                       \
        }                                 \
    }
#define CHECK_ARG_SIZE(t, want, got)              \
    {                                             \
        if (want != got) {                        \
            invalid_type_size(err, t, want, got); \
			return;                               \
        }                                         \
    }
#define MARSHAL_FAILED(obj) error_put(err, "marshal struct " obj " failed");
#define UNMARSHAL_FAILED(obj) error_put(err, "unmarshal struct " obj " failed")


void string_toupper_handler(request_t* req, error_t* err, struct argument* resp) {
	char* arg1;
	char* res = NULL;

	CHECK_ARG_CNT(1, req->argcnt)
	CHECK_ARG_TYPE("string", req->args[0].type_name)
	
	arg1 = req->args[0].data;
	
	res = string_toupper(arg1, err);
	if (!err->null) goto end;
	build_resp(resp, 0, "string", res == NULL? 0 : strlen(res), res);
end:
	free(res);
	return;
}

void string_tolower_handler(request_t* req, error_t* err, struct argument* resp) {
	char* arg1;
	char* res = NULL;

	CHECK_ARG_CNT(1, req->argcnt)
	CHECK_ARG_TYPE("string", req->args[0].type_name)
	
	arg1 = req->args[0].data;
	
	res = string_tolower(arg1, err);
	if (!err->null) goto end;
	build_resp(resp, 0, "string", res == NULL? 0 : strlen(res), res);
end:
	free(res);
	return;
}

void string_concat_handler(request_t* req, error_t* err, struct argument* resp) {
	char* arg1;
	char* arg2;
	char* res = NULL;

	CHECK_ARG_CNT(2, req->argcnt)
	CHECK_ARG_TYPE("string", req->args[0].type_name)
	
	CHECK_ARG_TYPE("string", req->args[1].type_name)
	
	arg1 = req->args[0].data;
	arg2 = req->args[1].data;
	
	res = string_concat(arg1, arg2, err);
	if (!err->null) goto end;
	build_resp(resp, 0, "string", res == NULL? 0 : strlen(res), res);
end:
	free(res);
	return;
}

void string_atoi_handler(request_t* req, error_t* err, struct argument* resp) {
	char* arg1;
	int32_t res;

	CHECK_ARG_CNT(1, req->argcnt)
	CHECK_ARG_TYPE("string", req->args[0].type_name)
	
	arg1 = req->args[0].data;
	
	res = string_atoi(arg1, err);
	if (!err->null) goto end;
	build_resp(resp, 0, "int32", 4, (char*)&res);
end:
	return;
}


void register_string_service(server_t* svr) {
	server_register(svr, "string.toupper", string_toupper_handler);
	server_register(svr, "string.tolower", string_tolower_handler);
	server_register(svr, "string.concat", string_concat_handler);
	server_register(svr, "string.atoi", string_atoi_handler);
}